---
title: "LDA for Aging"
output: html_notebook
---



# This is the journal summary of the LDAs that I've done so far. 

## Simple LDA where the dimensions are each of the channels
- I ran a simple LDA here, given the data that KK transformed for me. 
- Each of the dimensions it reduces are all the densities in each of the channels
- Dimensions are blind to what subrois they belong to. 
- Result: the groups are not so different. 
- this is from "lda.R"




```{r}
# LDA

r = lda(formula = grain ~ AREAmm2, DAPI, H2BGFP, GFAP, ArcIHC, OL, NormOL,
        data = kk)
r2 = lda(formula = grain ~ AREAmm2, DAPI, H2BGFP, GFAP, ArcIHC, OL, NormOL,
         data = kk, CV=T)

prop = r$svd^2/sum(r$svd^2)

plda = predict(object = r, newdata = kk)

head(plda)

dataset = data.frame(grain = kk$grain, 
                     lda = plda$x)

ggplot(dataset) + 
  aes(lda.LD1, lda.LD2, color = group, alpha = 0.1) +
  #geom_point() + 
  xlim(-4,4) + ylim(-3,3) +
  stat_ellipse() +
  ggtitle("lda with only the groups, and channels are dimensions")


```


## LDA on the raw data set (not from KK)
- KK's data didn't give me enough information into the other details.
- I ran the LDA on my own raw dataset
-
- 

```{r, warning=F, message=F}
# LDA on the raw dataset
require(MASS)

raw$grain = paste(raw$GROUP, raw$EXPT)
lda.df = raw[c(17:28, 34:53, 55)]

r = lda(formula = grain ~ .,
        data = lda.df)
# r2 = lda(formula = grain ~ AREAmm2, DAPI, H2BGFP, GFAP, ArcIHC, OL, NormOL,
#          data = kk, CV=T)
prop = r$svd^2/sum(r$svd^2)

plda = predict(object = r, newdata = lda.df)
head(plda)
dataset = data.frame(grain = raw$grain, 
                     subexpt = raw$SUBEXPT, # will facet by AA/AB
                     expt = raw$EXPT, 
                     group = raw$GROUP, # will facet by age
                     lda = plda$x)

library(ggplot2)

# compares young vs old
ggplot(dataset) + 
  aes(lda.LD1, lda.LD2, color = grain) +
  #geom_point() + 
  stat_ellipse() + facet_wrap(~group)

# compares AA vs AB
ggplot(dataset) + 
  aes(lda.LD1, lda.LD2, color = grain) +
  #geom_point() + 
  xlim(-4,4) + ylim(-3,3) +
  stat_ellipse() + facet_wrap(~subexpt)


# compares young vs old
ggplot(dataset) + 
  aes(lda.LD1, lda.LD2, color = grain) +
  #geom_point() + 
  xlim(-4,4) + ylim(-3,3) +
  stat_ellipse() + facet_wrap(~expt)




```


## LDA for each channel



```{r}
# do an LDA for each channel, for each region

library(reshape2)

kk$GRAIN = paste(kk$GROUP, kk$EXPT)

# we have to cast the kk data into different dataframes
# and then widen the subroi variable
# split kk into different channels for lda
lda.dapi = dcast(kk, GRAIN + ID ~ SUBROI, value.var = "DAPI")
lda.gfp = dcast(kk, GRAIN + ID ~ SUBROI, value.var = "H2BGFP")
lda.gfap = dcast(kk, GRAIN + ID ~ SUBROI, value.var = "GFAP")
lda.arc = dcast(kk, GRAIN + ID ~ SUBROI, value.var = "ArcIHC")
lda.ol = dcast(kk, GRAIN + ID ~ SUBROI, value.var = "OL")
lda.olnorm = dcast(kk, GRAIN + ID ~ SUBROI, value.var = "NormOL")


# make the lda for dapi
dapi = lda(formula = GRAIN ~ ., data = lda.dapi)
prop.dapi = dapi$svd^2/sum(dapi$svd^2)
plda.dapi = predict(object = dapi, newdata = lda.dapi)
head(plda.dapi)
dataset.dapi = data.frame(GRAIN = lda.dapi$GRAIN, lda = plda.dapi$x)
ggplot(dataset.dapi) + aes(lda.LD1, lda.LD2, color=GRAIN, label=GRAIN) + 
  stat_ellipse() + geom_text() + 
  ggtitle("LDA for DAPI")

# make the lda for arc
arc = lda(formula = GRAIN ~., data = lda.arc)
prop.arc = arc$svd^2 / sum(arc$svd^2)
plda.arc = predict(object = arc, newdata = lda.arc)
head(plda.arc)
dataset.arc = data.frame(GRAIN = lda.arc$GRAIN, lda = plda.arc$x)
# visualize
ggplot(dataset.arc) + aes(lda.LD1, lda.LD2, color=GRAIN, label=GRAIN) + 
  stat_ellipse() + geom_text() + 
  ggtitle("LDA for ARC based only on homogenous expression")

# make the lda for gfp
gfp = lda(formula = GRAIN ~., data = lda.gfp)
prop.gfp = gfp$svd^2 / sum(gfp$svd^2)
plda.gfp = predict(object = gfp, newdata = lda.gfp)
dataset.gfp = data.frame(GRAIN = lda.gfp$GRAIN, lda = plda.gfp$x)
# visualize
ggplot(dataset.gfp) + aes(lda.LD1, lda.LD2, color=GRAIN, label=GRAIN) + 
  stat_ellipse() + geom_text() + 
  ggtitle("LDA for H2BGFP based only on homogenous expression")


# make the lda for gfap
gfap = lda(formula = GRAIN ~., data = lda.gfap)
prop.gfap = gfap$svd^2 / sum(gfap$svd^2)
plda.gfap = predict(object = gfap, newdata = lda.gfap)
dataset.gfap = data.frame(GRAIN = lda.gfap$GRAIN, lda = plda.gfap$x)
# visualize
ggplot(dataset.gfap) + aes(lda.LD1, lda.LD2, color=GRAIN, label=GRAIN) + 
  stat_ellipse() + geom_text() + 
  ggtitle("LDA for GFAP based only on homogenous expression")


# make the lda for ol
ol = lda(formula = GRAIN ~., data = lda.ol)
prop.ol = ol$svd^2 / sum(ol$svd^2)
plda.ol = predict(object = ol, newdata = lda.ol)
dataset.ol = data.frame(GRAIN = lda.ol$GRAIN, lda = plda.ol$x)
# visualize
ggplot(dataset.ol) + aes(lda.LD1, lda.LD2, color=GRAIN, label=GRAIN) + 
  stat_ellipse() + geom_text() + 
  ggtitle("LDA for OL based only on homogenous expression")

# make the lda for olnorm
olnorm = lda(formula = GRAIN ~., data = lda.olnorm)
prop.olnorm = olnorm$svd^2 / sum(olnorm$svd^2)
plda.olnorm = predict(object = olnorm, newdata = lda.olnorm)
dataset.olnorm = data.frame(GRAIN = lda.olnorm$GRAIN, lda = plda.olnorm$x)
# visualize
ggplot(dataset.olnorm) + aes(lda.LD1, lda.LD2, color=GRAIN, label=GRAIN) + 
  stat_ellipse() + geom_text() + 
  ggtitle("LDA for OL.norm based only on homogenous expression")





```



## Did the batch analysis
- I noticed that the batches were evident in the LDAs
- So I added a new variable called BATCH that reflects when I stained them

```{r}


# Purpose of this script:
# Import the batch details as a variable BATCH
# Then normalize within the batches
# Then do the LDA and see the differences




# modified from "lda4.R"
# one big LDA for all the (channels x subroi)
# each (ch x subroi) is a concatenated variable

library(reshape2)

kk.long2 = kk.long
kk.long2$GRAIN = paste(kk.long2$GROUP, kk.long2$EXPT)

  batch_details = read.csv("batch_details.csv")
  colnames(batch_details) = c("GRAIN", "BATCH")
  kk.long2 = merge(kk.long2, batch_details, by="GRAIN")

kk.long2$roi_channel = paste(kk.long2$SUBROI, kk.long2$CHANNEL)

lda.roi_channel.batch = dcast(kk.long2, BATCH + ID ~ roi_channel, value.var="DENSITY")

# shuffle batch
# temp = lda.roi_channel.batch
# lda.roi_channel.batch$BATCH = sample(lda.roi_channel.batch$BATCH)
# lda.roi_channel.batch = temp

roi_channel.batch = lda(formula = BATCH ~ ., data = lda.roi_channel.batch)
prop.roi_channel.batch = roi_channel.batch$svd^2/sum(roi_channel.batch$svd^2)
plda.roi_channel.batch = predict(object = roi_channel.batch, newdata = lda.roi_channel.batch)
head(plda.roi_channel.batch)
dataset.roi_channel.batch = data.frame(BATCH = lda.roi_channel.batch$BATCH, lda = plda.roi_channel.batch$x)
ggplot(dataset.roi_channel.batch) + aes(lda.LD1, lda.LD2, color=BATCH, label=BATCH) + 
  stat_ellipse() + geom_text() + 
  ggtitle("LDA for all by BATCH")


# but the question is whether they are different in the DAPI channel
# i wonder if i can make function that does this


```











